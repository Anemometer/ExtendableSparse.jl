var documenterSearchIndex = {"docs":
[{"location":"#","page":"Home","title":"Home","text":"using Markdown\nMarkdown.parse(\"\"\"\n$(read(\"../../README.md\",String))\n\"\"\")","category":"page"},{"location":"example/#Examples-1","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"example/#","page":"Examples","title":"Examples","text":"An ExtendableSparseMatrix can serve as a drop-in replacement for SparseMatrixCSC, albeit with faster assembly.","category":"page"},{"location":"example/#","page":"Examples","title":"Examples","text":"The code below provides a small benchmark example.","category":"page"},{"location":"example/#","page":"Examples","title":"Examples","text":"using ExtendableSparse\nusing SparseArrays\n\nfunction ext_create(n)\n    A=ExtendableSparseMatrix(n,n)\n    sprand_sdd!(A);\nend\n\nfunction csc_create(n)\n    A=spzeros(n,n)\n    sprand_sdd!(A);\nend\n\n# Trigger JIT compilation before timing\ncsc_create(10);\next_create(10);\n\nn=90000\n@time Acsc=csc_create(n);\nnnz(Acsc)\n@time Aext=ext_create(n);\nnnz(Aext)\nb=rand(n);\n@time Acsc*(Acsc\\b)≈b\n@time Aext*(Aext\\b)≈b","category":"page"},{"location":"example/#","page":"Examples","title":"Examples","text":"The function sprand_sdd! fills a  sparse matrix with random entries such that it becomes strictly diagonally dominant and thus invertible and has a fixed number of nonzeros in its rows. Its  bandwidth is bounded by 2*sqrt(n), therefore it  resembles a typical matrix of a 2D piecewise linear FEM discretization. For filling a matrix a, the method  conveniently albeit naively uses just a[i,j]=value. This approach is considerably faster with  the ExtendableSparseMatrix which uses a linked list based structure  SparseMatrixLNK to grab new entries.","category":"page"},{"location":"changes/#Changes-1","page":"Changes","title":"Changes","text":"","category":"section"},{"location":"changes/#dev-1","page":"Changes","title":"dev","text":"","category":"section"},{"location":"changes/#","page":"Changes","title":"Changes","text":"Tried to track down the source from which I learned the linked list based struct in order to document this. Ended up with SPARSEKIT of Y.Saad, however I believe this  already was in SPARSEPAK by Chu,George,Liu.\nInternal rename of SparseMatrixExtension to SparseMatrixLNK. ","category":"page"},{"location":"changes/#v0.2-Dec-2019-1","page":"Changes","title":"v0.2 Dec 2019","text":"","category":"section"},{"location":"changes/#","page":"Changes","title":"Changes","text":"more interface methods delegating to csc, in particular mul! and ldiv!\nlazy creation of extendable part: don't create idle memory\nnicer constructors","category":"page"},{"location":"changes/#V0.1,-July-2019-1","page":"Changes","title":"V0.1, July 2019","text":"","category":"section"},{"location":"changes/#","page":"Changes","title":"Changes","text":"Initial release","category":"page"},{"location":"api/#API-1","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Types-and-Constants-1","page":"API","title":"Types and Constants","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Modules = [ExtendableSparse]\nPages = [\"sparsematrixlnk.jl\",\"extendable.jl\"]\nOrder = [:type]","category":"page"},{"location":"api/#ExtendableSparse.SparseMatrixLNK","page":"API","title":"ExtendableSparse.SparseMatrixLNK","text":"mutable struct SparseMatrixLNK{Tv, Ti<:Integer} <: SparseArrays.AbstractSparseArray{Tv,Ti<:Integer,2}\n\nStruct to hold sparse matrix in the linked list format.\n\nModeled after the linked list sparse matrix format described in  the  whitepaper and the  SPARSEKIT2 source code by Y. Saad. He writes \"This is one of the oldest data structures used for sparse matrix computations.\"\n\nThe relevant source formats.f is also available in the debian/science gitlab.\n\nProbably this format was around already in SPARSPAK by E.Chu, A.George and J.Liu, however this is  hard to verify, as it indeed appears that the source code of SPARSPAK vanished from the internet.\n\nThe advantage of the linked list structure is the fact that upon insertion of a new entry, the arrays describing the structure grow at their respective ends and can be conveniently updated via push!.  Now copying of existing data is necessary.\n\nm::Integer\nNumber of rows\n\nn::Integer\nNumber of columns\n\nnnz::Integer\nNumber of nonzeros\n\ncolptr::Array{Ti,1} where Ti<:Integer\nLinked list of column entries. Initial length is n, it grows with each new entry.\ncolptr[index] contains the next index in the list or zero, in the later case terminating the list which starts at index 1<=j<=n for each column j.\n\nrowval::Array{Ti,1} where Ti<:Integer\nRow numbers. For each index it contains the zero (initial state) or the row numbers corresponding to the column entry list in colptr.\nInitial length is n, it grows with each new entry.\n\nnzval::Array{Tv,1} where Tv\nNonzero entry values correspondin to each pair (colptr[index],rowval[index])\nInitial length is n,  it grows with each new entry.\n\n\n\n\n\n","category":"type"},{"location":"api/#ExtendableSparse.SparseMatrixLNK-Union{Tuple{Ti}, Tuple{Tv}, Tuple{Integer,Integer}} where Ti<:Integer where Tv","page":"API","title":"ExtendableSparse.SparseMatrixLNK","text":"Constructor of empty extension\n\n\n\n\n\n","category":"method"},{"location":"api/#ExtendableSparse.ExtendableSparseMatrix","page":"API","title":"ExtendableSparse.ExtendableSparseMatrix","text":"mutable struct ExtendableSparseMatrix{Tv, Ti<:Integer} <: SparseArrays.AbstractSparseArray{Tv,Ti<:Integer,2}\n\nExtendable sparse matrix. A nonzero  entry of this matrix is contained either in cscmatrix, or in lnkmatrix, never in both.\n\ncscmatrix::SparseArrays.SparseMatrixCSC\nFinal matrix data\n\nlnkmatrix::Union{Nothing, SparseMatrixLNK{Tv,Ti}} where Ti<:Integer where Tv\nLinked list structure holding data of extension\n\n\n\n\n\n","category":"type"},{"location":"api/#ExtendableSparse.ExtendableSparseMatrix-Tuple{Integer,Integer}","page":"API","title":"ExtendableSparse.ExtendableSparseMatrix","text":"ExtendableSparseMatrix(m, n)\n\n\nCreate empty ExtendableSparseMatrix. This is a pendant to spzeros.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExtendableSparse.ExtendableSparseMatrix-Union{Tuple{SparseMatrixCSC{Tv,Ti}}, Tuple{Ti}, Tuple{Tv}} where Ti<:Integer where Tv","page":"API","title":"ExtendableSparse.ExtendableSparseMatrix","text":"ExtendableSparseMatrix(M)\n\n\nCreate ExtendableSparseMatrix from sparse matrix\n\n\n\n\n\n","category":"method"},{"location":"api/#ExtendableSparse.ExtendableSparseMatrix-Union{Tuple{Ti}, Tuple{Tv}, Tuple{Integer,Integer}} where Ti<:Integer where Tv","page":"API","title":"ExtendableSparse.ExtendableSparseMatrix","text":"ExtendableSparseMatrix(m, n)\n\n\nCreate empty ExtendableSparseMatrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExtendableSparse.ExtendableSparseMatrix-Union{Tuple{Ti}, Tuple{Tv}, Tuple{Type{Tv},Type{Ti},Integer,Integer}} where Ti<:Integer where Tv","page":"API","title":"ExtendableSparse.ExtendableSparseMatrix","text":"ExtendableSparseMatrix(?, ?, m, n)\n\n\nCreate empty ExtendableSparseMatrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExtendableSparse.ExtendableSparseMatrix-Union{Tuple{Tv}, Tuple{Type{Tv},Integer,Integer}} where Tv","page":"API","title":"ExtendableSparse.ExtendableSparseMatrix","text":"ExtendableSparseMatrix(?, m, n)\n\n\nCreate empty ExtendablSparseMatrix. This is a pendant to spzeros.\n\n\n\n\n\n","category":"method"},{"location":"api/#","page":"API","title":"API","text":"Modules = [ExtendableSparse]\nPages = [\"sparsematrixlnk.jl\",\"extendable.jl\"]\nOrder = [:constant]","category":"page"},{"location":"api/#Methods-1","page":"API","title":"Methods","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Modules = [ExtendableSparse]\nPages = [\"sparsematrixlnk.jl\",\"extendable.jl\", \"sprand.jl\"]\nOrder = [:function]","category":"page"},{"location":"api/#ExtendableSparse.flush!-Union{Tuple{SparseMatrixLNK{Tv,Ti}}, Tuple{Ti}, Tuple{Tv}} where Ti where Tv","page":"API","title":"ExtendableSparse.flush!","text":"Dummy flush! method for Sparse matrix extension. Just used in test methods\n\n\n\n\n\n","category":"method"},{"location":"api/#SparseArrays.nnz-Tuple{SparseMatrixLNK}","page":"API","title":"SparseArrays.nnz","text":"nnz(E)\n\n\nReturn number of nonzero entries.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExtendableSparse.colptrs-Tuple{ExtendableSparseMatrix}","page":"API","title":"ExtendableSparse.colptrs","text":"colptrs(E)\n\n\nFlush and delegate to cscmatrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExtendableSparse.flush!-Union{Tuple{ExtendableSparseMatrix{Tv,Ti}}, Tuple{Ti}, Tuple{Tv}} where Ti<:Integer where Tv","page":"API","title":"ExtendableSparse.flush!","text":"If there are new entries in extension, create new CSC matrix using _splice and reset extension.\n\n\n\n\n\n","category":"method"},{"location":"api/#SparseArrays.nnz-Tuple{ExtendableSparseMatrix}","page":"API","title":"SparseArrays.nnz","text":"nnz(E)\n\n\nNumber of nonzeros of ExtendableSparseMatrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExtendableSparse.sprand!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AbstractSparseArray{Tv,Ti,2},Int64}} where Ti where Tv","page":"API","title":"ExtendableSparse.sprand!","text":"sprand!(A, xnnz)\n\n\nFill empty sparse matrix A with random nonzero elements from interval [1,2] using incremental assembly.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExtendableSparse.sprand_sdd!-Union{Tuple{AbstractSparseArray{Tv,Ti,2}}, Tuple{Ti}, Tuple{Tv}} where Ti where Tv","page":"API","title":"ExtendableSparse.sprand_sdd!","text":"Fill sparse matrix  with random entries such that  it becomes strictly diagonally  dominant  and  thus  invertible and  has  a  fixed  number nnzrow (default: 4) of nonzeros in its rows. The matrix bandwidth is bounded by  sqrt(n) in order to resemble  a typical matrix of  a 2D piecewise linear FEM discretization.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseMatrixLNK{Tv,Ti},Integer,Integer}} where Ti<:Integer where Tv","page":"API","title":"Base.getindex","text":"getindex(E, i, j)\n\n\nReturn value stored for entry or zero if not found\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.setindex!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseMatrixLNK{Tv,Ti},Any,Integer,Integer}} where Ti<:Integer where Tv","page":"API","title":"Base.setindex!","text":"setindex!(E, _v, _i, _j)\n\n\nUpdate value of existing entry, otherwise extend matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.size-Tuple{SparseMatrixLNK}","page":"API","title":"Base.size","text":"size(E)\n\n\nReturn tuple containing size of the matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Union{Tuple{Ti}, Tuple{Tv}, Tuple{ExtendableSparseMatrix{Tv,Ti},Integer,Integer}} where Ti<:Integer where Tv","page":"API","title":"Base.getindex","text":"getindex(M, i, j)\n\n\nFind index in CSC matrix and return value, if it exists. Otherwise, return value from extension.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.setindex!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{ExtendableSparseMatrix{Tv,Ti},Any,Integer,Integer}} where Ti<:Integer where Tv","page":"API","title":"Base.setindex!","text":"setindex!(M, v, i, j)\n\n\nFind index in CSC matrix and set value if it exists. Otherwise, set index in extension.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.size-Tuple{ExtendableSparseMatrix}","page":"API","title":"Base.size","text":"size(E)\n\n\nSize of ExtendableSparseMatrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExtendableSparse._splice-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseMatrixLNK{Tv,Ti},SparseMatrixCSC{Tv,Ti}}} where Ti<:Integer where Tv","page":"API","title":"ExtendableSparse._splice","text":"_splice(lnk, csc)\n\n\nCreate new CSC matrix with sorted entries from a SparseMatrixCSC  csc and  SparseMatrixLNK  lnk.\n\nThis method assumes that there are no entries with the same indices in lnk and csc, therefore  it appears too dangerous for general use and so we don't export it.  A generalization appears to be possible, though.\n\n\n\n\n\n","category":"method"},{"location":"api/#ExtendableSparse.findindex-Union{Tuple{T}, Tuple{SparseMatrixCSC{T,Ti} where Ti<:Integer,Integer,Integer}} where T","page":"API","title":"ExtendableSparse.findindex","text":"findindex(S, i, j)\n\n\nReturn index corresponding to entry [i,j] in the array of nonzeros, if the entry exists, otherwise, return 0.\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.ldiv!-Tuple{AbstractArray{T,1} where T,ExtendableSparseMatrix,AbstractArray{T,1} where T}","page":"API","title":"LinearAlgebra.ldiv!","text":"ldiv!(r, E, x)\n\n\nDelegating Matrix ldiv\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.ldiv!-Tuple{AbstractArray{T,2} where T,ExtendableSparseMatrix,AbstractArray{T,2} where T}","page":"API","title":"LinearAlgebra.ldiv!","text":"ldiv!(r, E, x)\n\n\nDelegating Matrix ldiv\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.lu-Tuple{ExtendableSparseMatrix}","page":"API","title":"LinearAlgebra.lu","text":"lu(E)\n\n\nDelegating LU factorization.\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.mul!-Tuple{AbstractArray{T,1} where T,ExtendableSparseMatrix,AbstractArray{T,1} where T}","page":"API","title":"LinearAlgebra.mul!","text":"mul!(r, E, x)\n\n\nDelegating Matrix multiplication\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.mul!-Tuple{AbstractArray{T,2} where T,ExtendableSparseMatrix,AbstractArray{T,2} where T}","page":"API","title":"LinearAlgebra.mul!","text":"mul!(r, E, x)\n\n\nDelegating Matrix multiplication\n\n\n\n\n\n","category":"method"},{"location":"api/#SparseArrays.findnz-Tuple{ExtendableSparseMatrix}","page":"API","title":"SparseArrays.findnz","text":"findnz(E)\n\n\nFlush and delegate to cscmatrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#SparseArrays.nonzeros-Tuple{ExtendableSparseMatrix}","page":"API","title":"SparseArrays.nonzeros","text":"nonzeros(E)\n\n\nFlush and delegate to cscmatrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#SparseArrays.rowvals-Tuple{ExtendableSparseMatrix}","page":"API","title":"SparseArrays.rowvals","text":"rowvals(E)\n\n\nFlush and delegate to cscmatrix.\n\n\n\n\n\n","category":"method"}]
}
